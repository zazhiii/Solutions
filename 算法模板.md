# 最短路

## dijkstra

[P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

```java
import java.io.*;
import java.util.*;

public class Main {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    static int n, m, s, d[], inf = (int)1e9;
    static boolean vis[];
    static Vector<int[]> adj[];
    static Queue<int[]> que = new PriorityQueue<>((a, b) -> a[1] - b[1]);
    public static void main(String[] args) throws IOException {
        n = rd.nextInt();
        m = rd.nextInt();
        s = rd.nextInt();
        d = new int[n + 1];
        vis = new boolean[n + 1];
        adj = new Vector[n + 1];
        Arrays.setAll(adj, i -> new Vector<>());
        while(m --> 0){
            int u = rd.nextInt();
            int v = rd.nextInt();
            int w = rd.nextInt();
            adj[u].add(new int[]{v, w});
        }
        Arrays.fill(d, inf);
        d[s] = 0;
        que.add(new int[]{s, d[s]});
        while(!que.isEmpty()){
            int u[] = que.poll();
            if(vis[u[0]]) continue;
            vis[u[0]] = true;
            for(int v[] : adj[u[0]]){
                if(d[v[0]] > d[u[0]] + v[1]){
                    d[v[0]] = d[u[0]] + v[1];
                    que.add(new int[]{v[0], d[v[0]]});
                }
            }
        }
        for(int i = 1; i <= n; i ++) pw.print(d[i] + " ");
        pw.flush();
    }   
}

class rd{
	static StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
	static public int nextInt() throws IOException {st.nextToken();return (int)st.nval;}
	static public long nextLong() throws IOException {st.nextToken();return (long)st.nval;}
}
```

# 并查集

[P3367 【模板】并查集 ](https://www.luogu.com.cn/problem/P3367) 

> 维护是否在一个集合

```java
import java.io.*;
import java.util.*;

public class Main {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
    static int n, m, p[];
    public static void main(String[] args) throws IOException {
        n = sc.nextInt();
        m = sc.nextInt();
        p = new int[n + 1];
        for(int i = 1; i <= n; i ++) p[i] = i;
        while(m --> 0){
            int op = sc.nextInt();
            int a = sc.nextInt();
            int b = sc.nextInt();
            if(op == 1) p[find(a)] = find(b);
            else pw.println(find(a) == find(b) ? "Y" : "N");
        }
        pw.flush();
    }   
    public static int find(int x){
        if(p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
}
```

> 维护是否在一个集合和每个集合的大小。