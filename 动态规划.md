# 动态规划入门题

## P1216 数字三角形 Number Triangles

[P1216 [USACO1.5\] [IOI1994]数字三角形 Number Triangles - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1216)

观察下面的数字金字塔。


写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)

在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。

> tags: dp

Ideas：

> 当前位置的最大权值由上几个位置的最大权值的最大值加上当前位置的元素值所得；
>
> tips： 记录元素的数组和dp数组都可优化为一维数组，读一行数据则更新一遍dp数组
>
> `dp[i]`：代表到当前位置的最大权值
>
> 当`i!=0`：`dp[i] = Math.max(dp[i], dp[i-1])+nums[i]`
>
> 当`i==0`：`dp[i] =dp[i]+nums[i]`

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int r = s.nextInt();
        int[] nums = new int[r];
        int[] dp = new int[r];
        for (int i = 0; i <= r - 1; i++) {
        	if(i==0) {
        		dp[0] = s.nextInt();//初始化dp数组
        	}
        	else {
                for (int j = 0; j <= i; j++) {//读入i行数据
                    nums[j] = s.nextInt();
                }
                for (int j = i; j >=0; j--) {//倒序遍历dp数组
            		if (j==0) {
						dp[j]= dp[j]+nums[j]; 
					}else {
						dp[j] = Math.max(dp[j], dp[j-1])+nums[j];
					}
            }          
			}
        }
        int res = 0;
        for (int i = 0; i <= r - 1; i++) {
            res = Math.max(res, dp[i]);
        }
        System.out.println(res);
    }
}
```

# 01背包

![image-20240206170315245](C:\Users\LXH15\AppData\Roaming\Typora\typora-user-images\image-20240206170315245.png)





## P1048 采药

[P1048 [NOIP2005 普及组\] 采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1048)

山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。

> tags：01背包

**Ideas：**

> ## 01背包模板题；
>
> ### 二维dp数组做法：
>
> 1. 确定`dp[i][j]`含义：在`j`时间里从`0~i`个草药采集的最大价值
> 2. 确定递推公式：对于第`i`个草药，我们可以选择采或者不采，对应`dp[i-1][j-time[i]]+value[i]`或者`dp[i-1][j]`，选择其中较大值则为`dp[i][j]`
> 3. 初始化`dp`数组：当`j==0`从`0~i`只能采集到价值为`0`的草药，当`i==0`（即只有第`0`个草药）当`j>=time(0)`可以采到该草药（即`dp[0][j]==value[0]`），反之则采不到（即`dp[0][j]==0`）
> 4. 确定遍历顺序：从`i==1`草药开始，对于所有时间`[1,T]`，判断第`i`个草药采或者不采，知道最后一个草药
> 5. 举例推导dp数组
>
> ## 一维dp数组：
>
> 用一维`dp[j]`数组记录`j`时间内`0~i`个草药里能采到的最大价值，每增加一个草药则更新一次dp数组；
>
> 遍历顺序：倒序遍历dp数组，如果`j>=time[i]`表示能采集当前草药，需要取采与不采的较大值，即`dp[j] =Math.max(dp[j],dp[j-time[i]]) `；反之则不可能采当前的草药，那么`dp[j] = dp[j]`
>
> 对于每一次更新整个数组：更新前`dp[j]`代表`j`时间在`0~i-1`内能采到的最大价值，更新后表示在`j`时间在`0~i`内能采到的最大价值

> 二维dp数组：

```java
import java.util.Scanner;
public class Main {
	static int T, M;
	static int[] time,value;
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        T = s.nextInt();
        M = s.nextInt();
        time = new int[M];
        value = new int[M];
        for (int i = 0; i <M; i++) {
			time[i]= s.nextInt();
			value[i] =s.nextInt();
		}
        int[][] dp = new int[M][T+1];
        //初始化dp
        for(int i =0;i<=M-1;i++) {
        	dp[i][0] = 0;
        }
        for(int i = 0;i<=T;i++) {
        	if (i>=time[0]) {
				dp[0][i] = value[0];
			}
        }
        //遍历
        for(int i = 1;i<=M-1;i++) {
        	for(int j = 1;j<=T;j++) {
        		if (j<time[i]) {
					dp[i][j] = dp[i-1][j]; 
				}else {
					dp[i][j]= Math.max(dp[i-1][j], dp[i-1][j-time[i]]+value[i]); 
				}
        	}
        }
        System.out.println(dp[M-1][T]);                
    }
}
```

> 一维dp数组

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
        int M = s.nextInt();
        int[] value = new int[M];
        int[] time = new int[M];
        for (int i = 0; i <= M - 1; i++) {
            time[i] = s.nextInt();
            value[i] = s.nextInt();
        }
        int[] dp = new int[T + 1];
        for (int i = 0; i <= M - 1; i++) {
            for (int j = T; j >= time[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - time[i]] + value[i]);
            }
        }
        System.out.println(dp[T]);
    }
}
```

## 分割两个最接近的子集

> 问题： 将一个集合分为两个最接近的子集。
>
> 设集合总和为`S`，用一个容量为`S/2`的背包去装集合里的元素，求得能装的最大值`dp[S/2-1]`则为小于`S/2`且最接近`S/2`的子集，`S-dp[S/2-1]`则为较大者子集；

### 416.分割等和子集

https://leetcode.cn/problems/partition-equal-subset-sum/

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int i =0;i<=nums.length-1;i++){
            sum+=nums[i];
        }
        if(sum%2!=0)return false;
        int target = sum/2;
        int[] dp = new int[target+1];
        for(int i =0;i<=nums.length-1;i++){
            for(int j = target;j>=nums[i];j--){
                dp[j] = Math.max(dp[j],dp[j-nums[i]]+nums[i]);           
            }
        }
        return dp[target]==target;
    }
}
```

### 1049. 最后一块石头的重量 II

[1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for(int i = 0;i<stones.length;i++){
            sum+=stones[i];
        }
        int target = sum/2;
        int[] dp = new int[target+1];
        for(int i = 0;i<=stones.length-1;i++){
            for(int j = target;j>=stones[i];j--){
                dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        int res = sum-2*dp[target];
        return res;
    }
}
```

### P2392 kkksc03考前临时抱佛脚

[P2392 kkksc03考前临时抱佛脚 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2392)

这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。


他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。


他希望知道能够完成复习的最短时间。

```java
import java.util.Scanner;
public class Main {	
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int[] S = new int[4];
        for(int i =0;i<=3;i++) {
        	S[i]=s.nextInt();
        }
        int min = 0;
        for (int i = 0; i <=3; i++) {
			int[] X = new int[S[i]];
			int sum = 0;
			for (int j = 0; j <=X.length-1; j++) {				
				X[j]= s.nextInt(); 
				sum+=X[j];
			}
			int target = sum/2;
        	int[] dp = new int[target+1];
        	for(int k = 0;k<=X.length-1;k++) {
        		for(int l = target;l>=X[k];l--) {
        			dp[l] = Math.max(dp[l], dp[l-X[k]]+X[k]);
        		}
        	}
        	min+=sum-dp[target];
		}
        System.out.println(min);
        }
    }
```

## P1802 5 倍经验日

[P1802 5 倍经验日 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1802)

 $x$ 个迷你装药物,准备开始与那些人打了。

现在有 $n$ 个好友，给定失败时可获得的经验、胜利时可获得的经验，打败他至少需要的药量。

要求求出最大经验 $s$，输出 $5s$。

> tags： 01背包

Ideas:

> 01背包问题的变形；**需要注意的是：不打这名好友也会获得一定经验值**
>
> 1. 确定`dp[j]`的含义：`j`个药，在`0~i`个好友中能获得的最大经验值；
> 2. 状态转移方程：当`j<cost[i]`不可能打过这位好友，直接获得失败经验值`lose[i]`，`dp[j] = dp[j]+lose[i]`（这一点和经典的01背包问题不同）；当`j>=cost[i]`时，则要判断打过经验多还是不打经验多，`dp[j] = Math.max(dp[j]+lose[i],dp[j-cost[i]]+win[i])`
> 3. 遍历顺序：对于每一个好友`i`倒序遍历`dp[j]`，直到第`x`个好友 

```java
import java.util.Scanner;
public class Main {	
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int N = s.nextInt();
        int x = s.nextInt();
        int[] lose = new int[N];
        int[] win = new int[N];
        int[] cost = new int [N];
        for(int i = 0;i<=N-1;i++) {
        	lose[i]= s.nextInt();
        	win[i]=s.nextInt();
        	cost[i]=s.nextInt();
        }
        long [] dp = new long [x+1];
        for(int i = 0;i<=N-1;i++) {
        	for(int j = x;j>=0;--j) {
        		if(j>=cost[i]) {
        			dp[j]=Math.max(dp[j]+lose[i], dp[j-cost[i]]+win[i]); 
        		}else {
        			dp[j]=dp[j]+lose[i]; 
        		}        		
        	}
        }
        System.out.println(dp[x]*5);
        }
    }
```









# P2196挖地雷

[P2196 [NOIP1996 提高组\] 挖地雷 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2196)

在一个地图上有 $N\ (N \le 20)$ 个地窖，每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。

> dfs版

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
	static int N;
	static int[][] arr;
	static int count = 0;
	static int[] nums;
	static int max = 0;
	static int[] res;
	static int[] temp;
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        N = s.nextInt();
        res = new int[N];
        temp = new int[N];
        nums = new int[N];
        arr = new int[N-1][N-1];
        for(int i = 0;i<=N-1;i++) {
        	nums[i]= s.nextInt(); 
        }
        for(int i = 0;i<=N-2;i++) {
        	for(int j = 0;j<=N-i-2;j++) {
					arr[i][j]= s.nextInt(); 
				}
        	}
        dfs(0, 0,0);
        for (int i = 0; i<=N-1; i++) {
        	if (res[i]!=0) {
        		System.out.print(res[i]+" ");
			}			
		}
        System.out.println();
        System.out.println(max);          
        }    
    	public static void dfs(int startIdx,int preIdx,int n) {
    		
    		if (count>=max) {
				max = count;
				res = Arrays.copyOf(temp, N);
			}
    		for(int i =startIdx;i<=N-1;i++) {
    			if (preIdx!=startIdx && arr[preIdx][i-preIdx-1]==0) {
					continue;
				}
    			count+=nums[i];
    			temp[n] = i+1;
    			dfs(i+1,i,n+1);
    			count-=nums[i];
    			temp[n] = 0;
    		}  		
    	}
    }

```

> dp版

```java
import java.util.Scanner;

public class Main {
	static int N;
	static int[][] arr;
	static int[] nums;
	static int[] p;
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        N = s.nextInt();
        nums = new int[N+1];
        p = new int[N+1];
        arr = new int[N-1][N-1];
        int[] res = new int[N];
        for(int i = 1;i<=N;i++) {
        	nums[i]= s.nextInt(); 
        }
        for(int i = 0;i<=N-2;i++) {
        	for(int j = 0;j<=N-i-2;j++) {
					arr[i][j]= s.nextInt(); 
				}
        }
        //
        int[] dp = new int[N+1];
        dp[1] = nums[1];
        for(int i =2;i<=N;i++) {
        	int dpMax = 0;//dp[i]之前的最大值
        	int Index = 0;//dpmax的索引
        	for(int j = 1;j<=i-1;j++) {
        		if (arr[j-1][i-j-1]==1) {//判断有无通路
        			if (dp[j]>dpMax) {
						dpMax = dp[j];
						Index = j;						
					}
				}       		
        	}
        	p[i]=Index; 
        	dp[i]=dpMax+nums[i]; 
        }
        int max = 0;
        int x = 0;
        for (int i = 0; i < dp.length; i++) {
			if (dp[i]>max) {
				max = dp[i];
				x = i;
			}
		}
        res[N-1]=x;
        for (int i = 0; i <N-1; i++) {
			res[N-i-2] = p[x];
			x = p[x];
        }
        for (int i = 0; i <=N-1; i++) {
        	if (res[i]!=0) {
        		System.out.print(res[i]+" ");
			}
			
		}
        System.out.println();
        System.out.println(max);
        }
    }
```

